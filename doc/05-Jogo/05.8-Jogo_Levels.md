# `outside_neutros.gd`

Este script estende a classe `Node2D` e é usado para controlar o comportamento do jogo fora do ambiente dos neutros.

## Métodos

### `_ready()`

Método chamado quando o nó entra na árvore de cena pela primeira vez.

- Verifica se `Globals.isOnDoor` é falso. Se for, inicia o tutorial através do método `$GUI.startTutorial()`.
- Define `Globals.themes` como um array contendo os temas "A" e "N".
- Restaura a vida completa na barra de vida usando `$GUI.get_node("Control/healthbarBase/healthbar").fullLife()`.
- Se `Globals.isOnDoor` for verdadeiro:
  - Define `onDialog` como verdadeiro no nó `$GUI.get_node("paused")`.
  - Chama o método `setIdle()` no nó `$player` para colocá-lo em estado de repouso.

### `_on_checkpoint_7_body_entered(body)`

Callback chamado quando um corpo entra na área de um checkpoint específico (provavelmente um jogador).

- Define `onDialog` como verdadeiro no nó `$GUI.get_node("paused")`.
- Define `Globals.isOnDoor` como verdadeiro.

---

Este script controla aspectos importantes do jogo, como iniciar tutoriais, definir temas, gerenciar estados de diálogo e interações com checkpoints específicos. Ele utiliza variáveis globais (`Globals`) para armazenar e controlar o estado do jogo, garantindo que a lógica seja consistente e os elementos se comportem conforme o esperado dentro da cena do jogo.


# `first_floor_neutros.gd`

Este script estende a classe `Node2D` e controla o comportamento da primeira fase do ambiente dos neutros.

## Variáveis

- `spawnLocation`: Armazena a posição de spawn para o jogador.
- `coins`: Contador de moedas coletadas.

## Métodos

### `_ready()`

Método chamado quando o nó entra na árvore de cena pela primeira vez.

- Configura o contador de moedas usando `$GUI.setCoins(0)`.
- Define `spawnLocation` como a posição global do nó `$Spawn`.
- Define a posição global do jogador (`$player`) como `spawnLocation`.

### `_process(delta)`

Método chamado a cada quadro (frame), onde `delta` é o tempo decorrido desde o último quadro. Neste caso, não implementa nenhuma lógica específica.

---

Este script é responsável por configurar o estado inicial da fase dos neutros, incluindo a posição inicial do jogador e a inicialização do contador de moedas. Ele utiliza referências diretas aos nós da cena (`$Spawn` e `$player`) para definir o estado inicial e gerenciar a progressão do jogador dentro da fase.


# `second_floor_neutros.gd`

Este script estende a classe `Node2D` e controla o comportamento da segunda fase do ambiente dos neutros.

## Variáveis

- `plataformaAtual`: Armazena o número da plataforma atual onde o jogador está.

## Métodos

### `_ready()`

Método chamado quando o nó entra na árvore de cena pela primeira vez.

- Configura `plataformaAtual` com o valor de `Globals.plataformaAtual`.
- Define a vida do jogador para o máximo usando `$GUI.setFullLife()`.
- Se `Globals.onPuzzleLaser` for verdadeiro, reposiciona o jogador para a posição global de `$lasers/laserInteraction` e define a vida do jogador novamente.
- Se "laser" não estiver em `Globals.minigamesCompletes`, abre a porta `$doors/side_door3`.
- Verifica o nível atual (`Globals.currentLevel`) e, dependendo do nível e da plataforma atual (`plataformaAtual`), reposiciona o jogador para `$spawnLevelC` ou `$spawnLevelD`.
- Se `Globals.acesso` for "professor", mostra o nó `$GUI/configPlataforms`; caso contrário, esconde-o.
- Dependendo do nível atual (`Globals.currentLevel`), abre ou fecha a porta `$doors/side_door3`.

### `_process(delta)`

Método chamado a cada quadro (frame), onde `delta` é o tempo decorrido desde o último quadro. Neste caso, não implementa nenhuma lógica específica.

### `_on_colisaoplataforma_body_entered(body)`, `_on_colisaoplataforma_2_body_entered(body)`, `_on_colisaoplataforma_3_body_entered(body)`, `_on_colisaoplataforma_4_body_entered(body)`, `_on_area_2d_body_exited(body)`

Métodos que respondem quando o corpo `body` entra ou sai das áreas de colisão das plataformas. Eles atualizam `Globals.plataformaAtual` com diferentes valores dependendo da plataforma que o jogador entra ou sai.

### `enableAlarms()`

Ativa os alarmes no `TileMap` e cria um efeito de piscar na cor do nó.

### `_on_gui_on_dialog(onDialog)`

Método vazio que poderia ser utilizado para manipular eventos quando um diálogo (`onDialog`) é exibido na interface do usuário. Atualmente não possui implementação.

---

Este script gerencia o estado e o comportamento da segunda fase do jogo dos neutros, lidando com posicionamento do jogador, interação com plataformas, configurações de nível, e atualizações visuais na interface do usuário conforme necessário.



# `saving_amazon_endless.gd`

Este script controla o jogo "Saving Amazon Endless", onde o jogador ajuda Azurea a apagar incêndios na floresta através de operações matemáticas.

## Variáveis

- `bucket`: Instância do balde que o jogador utiliza para inserir respostas matemáticas.
- `files`: Script para obter arquivos de uma pasta.
- `azurea`: Quadros de expressões faciais de Azurea.
- `fire`: Cenário de objetos em chamas.
- `mathExpression`: Script para gerar expressões matemáticas.
- `getAudio`: Script para obter áudios.
- `random`: Gerador de números aleatórios.
- `fireTime`: Tempo inicial para cada instância de fogo.
- `fireMath`: Lista que armazena informações sobre fogo e suas expressões matemáticas.
- `doOnce`: Controle booleano para a execução única de uma ação.
- `stopGame`: Booleano para parar o jogo.
- `fireInstance`: Instância atual de fogo.
- `bossHealthBar`: Barra de vida do chefe.

## Métodos

### `_ready()`

Método chamado quando o nó entra na árvore de cena pela primeira vez.

- Inicializa variáveis e configurações necessárias para o jogo.
- Configura a barra de saúde do chefe (`bossHealthBar`) com a cena atual.
- Define a saúde inicial (`Globals.health`) como 3.
- Configura expressões faciais de Azurea, diálogos e volume de fala.
- Instancia e configura o balde (`bucket`) e o conecta ao método `checkBucketValue`.
- Esconde o balde e inicia o diálogo do jogador.
- Pausa a árvore de cena e inicia a reprodução do robô de fogo (`playFireRobot()`).

### `addFire()`

Adiciona uma nova instância de fogo ao cenário.

- Verifica as posições disponíveis para o fogo e as zonas de impacto.
- Gera uma expressão matemática para o fogo.
- Configura a instância de fogo com a expressão matemática, posição e tempo de espera.
- Conecta o evento `burn` da instância de fogo ao método `burnTrees`.

### `checkBucketValue(text)`

Verifica se o valor inserido no balde corresponde à resposta matemática de algum fogo.

- Filtra `fireMath` para encontrar uma correspondência.
- Se não houver correspondência, chama `hitWithoutPlayer()` na GUI.
- Se houver correspondência, reproduz sons apropriados, reduz a vida do chefe (`bossHealthBar`) e executa a ação de Azurea para apagar o fogo.

### `burnTrees(fire)`

Lida com a queima das árvores quando um fogo não é apagado a tempo.

- Se todas as zonas estiverem queimadas, direciona para a cena de game over.
- Remove a zona queimada, restaura a árvore para o estado normal e adiciona uma nova posição de destino para Azurea.
- Libera o fogo e reproduz o som de queima.

### `_on_timer_timeout()`

Chama `playFireRobot()` periodicamente para adicionar mais fogo ao jogo.

### `playFireRobot()`

Controla a lógica para adicionar fogo ao jogo.

- Verifica se há menos de 4 instâncias de fogo e o jogo não está parado (`stopGame`).
- Executa a animação de fogo do chefe (`boss01`) e adiciona três instâncias de fogo usando `addFire()`.

### `transitionFinished(node)`

Método chamado quando a transição de cena é concluída.

- Se `node` for o próprio nó, altera a cena para a tela de game over.

### `_process(delta)`

Método chamado a cada quadro (frame), onde `delta` é o tempo decorrido desde o último quadro.

- Verifica se a saúde do chefe (`bossHealthBar.health`) é zero e executa ações relacionadas ao término do jogo.

### `_on_gui_boss_health_bar_is_second_stage()`

Método chamado quando a barra de vida do chefe entra na segunda fase.

- Chama o método `secondStage()` de `boss01`.

---

Este script implementa a lógica principal do jogo "Saving Amazon Endless", incluindo a dinâmica de apagar incêndios com operações matemáticas, interação com o jogador e o chefe (boss01), e a transição entre cenas.
